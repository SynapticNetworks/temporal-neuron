package neuron

import (
	"fmt"
	"sync"
	"time"
)

/*
=================================================================================
COINCIDENCE DETECTION - TYPE-SAFE INTERFACE AND IMPLEMENTATIONS
=================================================================================

BIOLOGICAL OVERVIEW:
Coincidence detection is a fundamental neural computation where a neuron's
response is significantly amplified (or initiated) when multiple inputs arrive
within a narrow temporal window. This allows neurons to detect patterns,
correlations, and specific sequences of activity, underpinning functions like
associative learning, sensory processing, and motor control.

KEY BIOLOGICAL MECHANISMS MODELED:
1.  Temporal Summation: Inputs arriving close in time summate effectively.
2.  Nonlinear Amplification: Mechanisms like NMDA receptors or voltage-gated
    channels provide supra-linear responses to coincident inputs.
3.  Thresholding: A critical level of coincident input is required to trigger
    a robust response (e.g., a dendritic spike).
4.  Contextual Gating: Detection can be modulated by the neuron's current
    membrane potential (e.g., a back-propagating action potential enabling NMDA spikes).

ARCHITECTURAL INTEGRATION:
-   This module provides type-safe interfaces for different coincidence detection strategies.
-   These detectors are intended to be used by `DendriticIntegrationMode`
    implementations (e.g., `ActiveDendriteMode`) to add modular coincidence detection.
-   Full compile-time type safety with strongly-typed configuration objects.

=================================================================================
*/

// ============================================================================
// CORE TYPES AND RESULTS
// ============================================================================

// CoincidenceDetectionResult contains the outcome of a coincidence detection attempt.
type CoincidenceDetectionResult struct {
	CoincidenceDetected     bool      // True if a coincidence was detected
	AmplificationFactor     float64   // Factor by which net current should be multiplied
	AdditionalCurrent       float64   // Additional current (pA) generated by the coincidence
	AssociatedCalciumInflux float64   // Additional intracellular calcium from detection
	DetectionTime           time.Time // When the coincidence was detected
	Mechanism               string    // Name of the detection mechanism used
	DebugInfo               string    // Optional debug information for analysis
}

// ============================================================================
// TYPE-SAFE CONFIGURATION INTERFACES
// ============================================================================

// CoincidenceDetectorConfig defines the interface for all coincidence detector configurations.
// This provides compile-time type safety while allowing different detector implementations.
type CoincidenceDetectorConfig interface {
	// Core identification and validation
	DetectorType() string
	Validate() error

	// Common parameters that all detectors must support
	GetMinInputsRequired() int
	GetTemporalWindow() time.Duration

	// Configuration management
	Clone() CoincidenceDetectorConfig
	String() string // For debugging and logging
}

// BaseDetectorConfig provides common configuration parameters embedded by all detector configs.
// This ensures consistent behavior across different detector types while maintaining type safety.
type BaseDetectorConfig struct {
	MinInputsRequired int           `json:"min_inputs_required"` // Minimum inputs for coincidence
	TemporalWindow    time.Duration `json:"temporal_window"`     // Time window for coincidence
}

// Validate ensures the base configuration is valid.
func (c *BaseDetectorConfig) Validate() error {
	if c.MinInputsRequired < 1 {
		return fmt.Errorf("min_inputs_required must be >= 1, got %d", c.MinInputsRequired)
	}
	if c.TemporalWindow <= 0 {
		return fmt.Errorf("temporal_window must be positive, got %v", c.TemporalWindow)
	}
	if c.TemporalWindow > COINCIDENCE_TEMPORAL_WINDOW_LONG {
		return fmt.Errorf("temporal_window too large: %v > %v", c.TemporalWindow, COINCIDENCE_TEMPORAL_WINDOW_LONG)
	}
	return nil
}

// GetMinInputsRequired implements CoincidenceDetectorConfig interface.
func (c *BaseDetectorConfig) GetMinInputsRequired() int {
	return c.MinInputsRequired
}

// GetTemporalWindow implements CoincidenceDetectorConfig interface.
func (c *BaseDetectorConfig) GetTemporalWindow() time.Duration {
	return c.TemporalWindow
}

// SetDefaults applies default values to base configuration.
func (c *BaseDetectorConfig) SetDefaults() {
	if c.MinInputsRequired == 0 {
		c.MinInputsRequired = COINCIDENCE_MIN_INPUTS_REQUIRED
	}
	if c.TemporalWindow == 0 {
		c.TemporalWindow = COINCIDENCE_TEMPORAL_WINDOW_DEFAULT
	}
}

// ============================================================================
// NMDA COINCIDENCE DETECTOR CONFIGURATION
// ============================================================================

// NMDADetectorConfig provides type-safe configuration for NMDA-like coincidence detection.
// Models the voltage and ligand dependence of NMDA receptors for coincidence detection.
type NMDADetectorConfig struct {
	BaseDetectorConfig

	// Voltage gating parameters (models Mg2+ block/unblock)
	VoltageThreshold float64 `json:"voltage_threshold"` // mV - membrane potential for Mg2+ unblock

	// Current summation parameters
	CurrentThreshold float64 `json:"current_threshold"` // pA - minimum summed current for detection

	// Amplification parameters
	AmplificationFactor    float64 `json:"amplification_factor"`     // Multiplicative boost to signal
	AdditionalCurrentBoost float64 `json:"additional_current_boost"` // Additive current boost (pA)
	CalciumBoost           float64 `json:"calcium_boost"`            // Associated calcium influx

	// Back-propagating action potential gating
	EnableBackpropagationGating bool          `json:"enable_backpropagation_gating"` // Whether bAPs enable detection
	BackpropagationWindow       time.Duration `json:"backpropagation_window"`        // Time window for bAP influence
}

// DetectorType implements CoincidenceDetectorConfig interface.
func (c *NMDADetectorConfig) DetectorType() string {
	return "nmda_coincidence"
}

// Validate ensures the NMDA configuration is biologically reasonable.
func (c *NMDADetectorConfig) Validate() error {
	// Validate base configuration first
	if err := c.BaseDetectorConfig.Validate(); err != nil {
		return fmt.Errorf("base config invalid: %w", err)
	}

	// Validate NMDA-specific parameters
	if c.VoltageThreshold > -20.0 || c.VoltageThreshold < -80.0 {
		return fmt.Errorf("voltage_threshold must be between -80 and -20 mV, got %.1f", c.VoltageThreshold)
	}

	if c.CurrentThreshold <= 0 {
		return fmt.Errorf("current_threshold must be positive, got %.3f", c.CurrentThreshold)
	}

	if c.AmplificationFactor <= 0 {
		return fmt.Errorf("amplification_factor must be positive, got %.3f", c.AmplificationFactor)
	}

	if c.AdditionalCurrentBoost < 0 {
		return fmt.Errorf("additional_current_boost cannot be negative, got %.3f", c.AdditionalCurrentBoost)
	}

	if c.CalciumBoost < 0 {
		return fmt.Errorf("calcium_boost cannot be negative, got %.3f", c.CalciumBoost)
	}

	if c.EnableBackpropagationGating && c.BackpropagationWindow <= 0 {
		return fmt.Errorf("backpropagation_window must be positive when gating enabled, got %v", c.BackpropagationWindow)
	}

	return nil
}

// Clone creates a deep copy of the configuration.
func (c *NMDADetectorConfig) Clone() CoincidenceDetectorConfig {
	clone := *c // Struct copy
	return &clone
}

// String provides a human-readable representation for debugging.
func (c *NMDADetectorConfig) String() string {
	return fmt.Sprintf("NMDADetector(inputs=%d, window=%v, volt_thresh=%.1f, curr_thresh=%.1f, amp=%.1f)",
		c.MinInputsRequired, c.TemporalWindow, c.VoltageThreshold, c.CurrentThreshold, c.AmplificationFactor)
}

// SetDefaults applies biologically realistic default values.
func (c *NMDADetectorConfig) SetDefaults() {
	c.BaseDetectorConfig.SetDefaults()

	if c.VoltageThreshold == 0 {
		c.VoltageThreshold = COINCIDENCE_VOLTAGE_THRESHOLD_DEFAULT
	}
	if c.CurrentThreshold == 0 {
		c.CurrentThreshold = COINCIDENCE_CURRENT_THRESHOLD_DEFAULT
	}
	if c.AmplificationFactor == 0 {
		c.AmplificationFactor = COINCIDENCE_AMPLIFICATION_FACTOR_DEFAULT
	}
	if c.AdditionalCurrentBoost == 0 {
		c.AdditionalCurrentBoost = COINCIDENCE_AMPLIFICATION_CURRENT_BOOST_DEFAULT
	}
	if c.CalciumBoost == 0 {
		c.CalciumBoost = COINCIDENCE_AMPLIFICATION_CALCIUM_BOOST_DEFAULT
	}
	if c.EnableBackpropagationGating && c.BackpropagationWindow == 0 {
		c.BackpropagationWindow = COINCIDENCE_BACKPROPAGATION_AFFECT_WINDOW
	}
}

// DefaultNMDADetectorConfig creates a configuration with biologically realistic defaults.
func DefaultNMDADetectorConfig() *NMDADetectorConfig {
	config := &NMDADetectorConfig{
		BaseDetectorConfig: BaseDetectorConfig{
			MinInputsRequired: COINCIDENCE_MIN_INPUTS_REQUIRED,
			TemporalWindow:    COINCIDENCE_TEMPORAL_WINDOW_DEFAULT,
		},
		VoltageThreshold:            COINCIDENCE_VOLTAGE_THRESHOLD_DEFAULT,
		CurrentThreshold:            COINCIDENCE_CURRENT_THRESHOLD_DEFAULT,
		AmplificationFactor:         COINCIDENCE_AMPLIFICATION_FACTOR_DEFAULT,
		AdditionalCurrentBoost:      COINCIDENCE_AMPLIFICATION_CURRENT_BOOST_DEFAULT,
		CalciumBoost:                COINCIDENCE_AMPLIFICATION_CALCIUM_BOOST_DEFAULT,
		EnableBackpropagationGating: true, // Enable by default for biological realism
		BackpropagationWindow:       COINCIDENCE_BACKPROPAGATION_AFFECT_WINDOW,
	}
	return config
}

// ============================================================================
// SIMPLE TEMPORAL COINCIDENCE DETECTOR CONFIGURATION
// ============================================================================

// SimpleTemporalDetectorConfig provides type-safe configuration for basic temporal coincidence detection.
// Models simple threshold-based coincidence detection without voltage dependence.
type SimpleTemporalDetectorConfig struct {
	BaseDetectorConfig

	// Summation parameters
	MinimumSummedValue float64 `json:"minimum_summed_value"` // Minimum total value for detection

	// Optional amplification (usually minimal for "simple" detectors)
	AmplificationFactor float64 `json:"amplification_factor"` // Multiplicative boost (usually 1.0)
}

// DetectorType implements CoincidenceDetectorConfig interface.
func (c *SimpleTemporalDetectorConfig) DetectorType() string {
	return "simple_temporal_coincidence"
}

// Validate ensures the simple temporal configuration is valid.
func (c *SimpleTemporalDetectorConfig) Validate() error {
	// Validate base configuration first
	if err := c.BaseDetectorConfig.Validate(); err != nil {
		return fmt.Errorf("base config invalid: %w", err)
	}

	if c.MinimumSummedValue < 0 {
		return fmt.Errorf("minimum_summed_value cannot be negative, got %.3f", c.MinimumSummedValue)
	}

	if c.AmplificationFactor <= 0 {
		return fmt.Errorf("amplification_factor must be positive, got %.3f", c.AmplificationFactor)
	}

	return nil
}

// Clone creates a deep copy of the configuration.
func (c *SimpleTemporalDetectorConfig) Clone() CoincidenceDetectorConfig {
	clone := *c // Struct copy
	return &clone
}

// String provides a human-readable representation for debugging.
func (c *SimpleTemporalDetectorConfig) String() string {
	return fmt.Sprintf("SimpleTemporalDetector(inputs=%d, window=%v, min_sum=%.1f, amp=%.1f)",
		c.MinInputsRequired, c.TemporalWindow, c.MinimumSummedValue, c.AmplificationFactor)
}

// SetDefaults applies reasonable default values.
func (c *SimpleTemporalDetectorConfig) SetDefaults() {
	c.BaseDetectorConfig.SetDefaults()

	if c.MinimumSummedValue == 0 {
		c.MinimumSummedValue = 0.5 // Reasonable default for basic summation
	}
	if c.AmplificationFactor == 0 {
		c.AmplificationFactor = 1.0 // No amplification by default for "simple" detector
	}
}

// DefaultSimpleTemporalDetectorConfig creates a configuration with reasonable defaults.
func DefaultSimpleTemporalDetectorConfig() *SimpleTemporalDetectorConfig {
	config := &SimpleTemporalDetectorConfig{
		BaseDetectorConfig: BaseDetectorConfig{
			MinInputsRequired: COINCIDENCE_MIN_INPUTS_REQUIRED,
			TemporalWindow:    COINCIDENCE_TEMPORAL_WINDOW_DEFAULT,
		},
		MinimumSummedValue:  0.5, // Conservative threshold
		AmplificationFactor: 1.0, // No amplification by default
	}
	return config
}

// ============================================================================
// COINCIDENCE DETECTOR INTERFACE
// ============================================================================

// CoincidenceDetector defines the interface for different coincidence detection strategies.
// This allows for modular implementation of various biological coincidence mechanisms
// with full type safety.
type CoincidenceDetector interface {
	// Detect examines a set of inputs and the current membrane state to determine
	// if a coincidence event has occurred.
	//
	// Parameters:
	//   inputs: A slice of TimestampedInput representing recent synaptic events.
	//   state: A snapshot of the neuron's current membrane and activity state.
	//
	// Returns:
	//   CoincidenceDetectionResult: The outcome of the detection, including any
	//                               amplification or additional current.
	Detect(inputs []TimestampedInput, state MembraneSnapshot) CoincidenceDetectionResult

	// Configuration management
	GetConfig() CoincidenceDetectorConfig
	UpdateConfig(config CoincidenceDetectorConfig) error

	// Identification and metadata
	Name() string
	Type() string

	// Lifecycle management
	Close()
}

// ============================================================================
// NMDA COINCIDENCE DETECTOR IMPLEMENTATION
// ============================================================================

// NMDACoincidenceDetector models the properties of NMDA receptors, which require
// both presynaptic glutamate release (input) and postsynaptic depolarization
// (voltage) to open, leading to a large calcium and sodium influx.
//
// BIOLOGICAL BASIS:
// NMDA receptors are voltage-gated and ligand-gated. At resting potentials,
// their ion pore is blocked by Mg2+. Depolarization (often by AMPA receptor
// activation or back-propagating action potentials) expels Mg2+, allowing
// ion flow upon glutamate binding. This makes them ideal coincidence detectors.
type NMDACoincidenceDetector struct {
	config *NMDADetectorConfig
	mutex  sync.RWMutex
	name   string
}

// NewNMDACoincidenceDetector creates a new NMDA-like coincidence detector with type-safe configuration.
func NewNMDACoincidenceDetector(name string, config *NMDADetectorConfig) (*NMDACoincidenceDetector, error) {
	if config == nil {
		return nil, fmt.Errorf("config cannot be nil")
	}

	// Validate configuration
	if err := config.Validate(); err != nil {
		return nil, fmt.Errorf("invalid NMDA detector config: %w", err)
	}

	// Clone config to prevent external mutations
	clonedConfig := config.Clone().(*NMDADetectorConfig)

	return &NMDACoincidenceDetector{
		config: clonedConfig,
		name:   name,
	}, nil
}

// Detect checks for NMDA-like coincidence with full type safety.
func (d *NMDACoincidenceDetector) Detect(inputs []TimestampedInput, state MembraneSnapshot) CoincidenceDetectionResult {
	d.mutex.RLock()
	defer d.mutex.RUnlock()

	result := CoincidenceDetectionResult{
		CoincidenceDetected:     false,
		AmplificationFactor:     1.0,
		AdditionalCurrent:       0.0,
		AssociatedCalciumInflux: 0.0,
		DetectionTime:           time.Now(),
		Mechanism:               d.Type(),
	}

	// Early exit if insufficient inputs
	if len(inputs) < d.config.MinInputsRequired {
		result.DebugInfo = fmt.Sprintf("insufficient inputs: %d < %d", len(inputs), d.config.MinInputsRequired)
		return result
	}

	// Step 1: Filter inputs by temporal window and sum their effective current
	now := time.Now()
	var coincidentInputs []TimestampedInput
	var totalCoincidentCurrent float64

	cutoffTime := now.Add(-d.config.TemporalWindow)

	for _, input := range inputs {
		if input.ArrivalTime.After(cutoffTime) {
			coincidentInputs = append(coincidentInputs, input)
			// Apply spatial decay to input value
			totalCoincidentCurrent += input.Message.Value * input.DecayFactor
		}
	}

	// Check minimum inputs requirement after temporal filtering
	if len(coincidentInputs) < d.config.MinInputsRequired {
		result.DebugInfo = fmt.Sprintf("insufficient coincident inputs: %d < %d", len(coincidentInputs), d.config.MinInputsRequired)
		return result
	}

	// Step 2: Check current threshold
	if totalCoincidentCurrent < d.config.CurrentThreshold {
		result.DebugInfo = fmt.Sprintf("current below threshold: %.3f < %.3f", totalCoincidentCurrent, d.config.CurrentThreshold)
		return result
	}

	// Step 3: Check voltage threshold (Mg2+ unblock)
	voltageConditionMet := state.Accumulator >= d.config.VoltageThreshold

	// Apply back-propagation gating if enabled
	if d.config.EnableBackpropagationGating && state.BackPropagatingSpike {
		// bAP provides strong depolarization, assisting Mg2+ unblock
		voltageConditionMet = true
		result.DebugInfo += " [bAP gating active]"
	}

	if !voltageConditionMet {
		result.DebugInfo = fmt.Sprintf("voltage below threshold: %.1f < %.1f", state.Accumulator, d.config.VoltageThreshold)
		return result
	}

	// Coincidence detected!
	result.CoincidenceDetected = true
	result.AmplificationFactor = d.config.AmplificationFactor
	result.AdditionalCurrent = d.config.AdditionalCurrentBoost
	result.AssociatedCalciumInflux = d.config.CalciumBoost
	result.DebugInfo = fmt.Sprintf("coincidence detected: %d inputs, current=%.3f, voltage=%.1f",
		len(coincidentInputs), totalCoincidentCurrent, state.Accumulator)

	return result
}

// GetConfig returns a copy of the current configuration.
func (d *NMDACoincidenceDetector) GetConfig() CoincidenceDetectorConfig {
	d.mutex.RLock()
	defer d.mutex.RUnlock()
	return d.config.Clone()
}

// UpdateConfig updates the detector configuration with type safety.
func (d *NMDACoincidenceDetector) UpdateConfig(config CoincidenceDetectorConfig) error {
	nmdaConfig, ok := config.(*NMDADetectorConfig)
	if !ok {
		return fmt.Errorf("expected NMDADetectorConfig, got %T", config)
	}

	if err := nmdaConfig.Validate(); err != nil {
		return fmt.Errorf("invalid config: %w", err)
	}

	d.mutex.Lock()
	defer d.mutex.Unlock()

	// Clone config to prevent external mutations
	d.config = nmdaConfig.Clone().(*NMDADetectorConfig)
	return nil
}

// Name returns the human-readable identifier for this detector instance.
func (d *NMDACoincidenceDetector) Name() string {
	return d.name
}

// Type returns the detector type.
func (d *NMDACoincidenceDetector) Type() string {
	return d.config.DetectorType()
}

// Close performs any cleanup necessary for the detector.
func (d *NMDACoincidenceDetector) Close() {
	// No resources to release for this implementation
}

// ============================================================================
// SIMPLE TEMPORAL COINCIDENCE DETECTOR IMPLEMENTATION
// ============================================================================

// SimpleTemporalCoincidenceDetector provides a basic model of coincidence
// detection based purely on temporal summation within a defined window.
// It detects if a sufficient number of inputs arrive within that window.
type SimpleTemporalCoincidenceDetector struct {
	config *SimpleTemporalDetectorConfig
	mutex  sync.RWMutex
	name   string
}

// NewSimpleTemporalCoincidenceDetector creates a new basic temporal coincidence detector.
func NewSimpleTemporalCoincidenceDetector(name string, config *SimpleTemporalDetectorConfig) (*SimpleTemporalCoincidenceDetector, error) {
	if config == nil {
		return nil, fmt.Errorf("config cannot be nil")
	}

	// Validate configuration
	if err := config.Validate(); err != nil {
		return nil, fmt.Errorf("invalid simple temporal detector config: %w", err)
	}

	// Clone config to prevent external mutations
	clonedConfig := config.Clone().(*SimpleTemporalDetectorConfig)

	return &SimpleTemporalCoincidenceDetector{
		config: clonedConfig,
		name:   name,
	}, nil
}

// Detect checks for simple temporal coincidence.
func (d *SimpleTemporalCoincidenceDetector) Detect(inputs []TimestampedInput, state MembraneSnapshot) CoincidenceDetectionResult {
	d.mutex.RLock()
	defer d.mutex.RUnlock()

	result := CoincidenceDetectionResult{
		CoincidenceDetected:     false,
		AmplificationFactor:     d.config.AmplificationFactor,
		AdditionalCurrent:       0.0,
		AssociatedCalciumInflux: 0.0,
		DetectionTime:           time.Now(),
		Mechanism:               d.Type(),
	}

	// Early exit if insufficient inputs
	if len(inputs) < d.config.MinInputsRequired {
		result.DebugInfo = fmt.Sprintf("insufficient inputs: %d < %d", len(inputs), d.config.MinInputsRequired)
		return result
	}

	// Filter inputs by temporal window and calculate summation
	now := time.Now()
	var coincidentCount int
	var summedValue float64
	cutoffTime := now.Add(-d.config.TemporalWindow)

	for _, input := range inputs {
		if input.ArrivalTime.After(cutoffTime) {
			coincidentCount++
			summedValue += input.Message.Value * input.DecayFactor
		}
	}

	// Check if coincidence criteria are met
	if coincidentCount >= d.config.MinInputsRequired && summedValue >= d.config.MinimumSummedValue {
		result.CoincidenceDetected = true
		result.DebugInfo = fmt.Sprintf("coincidence detected: %d inputs, sum=%.3f", coincidentCount, summedValue)
	} else {
		result.DebugInfo = fmt.Sprintf("no coincidence: %d inputs, sum=%.3f (need %d inputs, %.3f sum)",
			coincidentCount, summedValue, d.config.MinInputsRequired, d.config.MinimumSummedValue)
	}

	return result
}

// GetConfig returns a copy of the current configuration.
func (d *SimpleTemporalCoincidenceDetector) GetConfig() CoincidenceDetectorConfig {
	d.mutex.RLock()
	defer d.mutex.RUnlock()
	return d.config.Clone()
}

// UpdateConfig updates the detector configuration with type safety.
func (d *SimpleTemporalCoincidenceDetector) UpdateConfig(config CoincidenceDetectorConfig) error {
	simpleConfig, ok := config.(*SimpleTemporalDetectorConfig)
	if !ok {
		return fmt.Errorf("expected SimpleTemporalDetectorConfig, got %T", config)
	}

	if err := simpleConfig.Validate(); err != nil {
		return fmt.Errorf("invalid config: %w", err)
	}

	d.mutex.Lock()
	defer d.mutex.Unlock()

	// Clone config to prevent external mutations
	d.config = simpleConfig.Clone().(*SimpleTemporalDetectorConfig)
	return nil
}

// Name returns the human-readable identifier for this detector instance.
func (d *SimpleTemporalCoincidenceDetector) Name() string {
	return d.name
}

// Type returns the detector type.
func (d *SimpleTemporalCoincidenceDetector) Type() string {
	return d.config.DetectorType()
}

// Close performs any cleanup necessary for the detector.
func (d *SimpleTemporalCoincidenceDetector) Close() {
	// No resources to release for this implementation
}

// ============================================================================
// TYPE-SAFE FACTORY FUNCTIONS
// ============================================================================

// CreateNMDACoincidenceDetector creates an NMDA detector with optional custom configuration.
// If config is nil, uses biologically realistic defaults.
func CreateNMDACoincidenceDetector(name string, config *NMDADetectorConfig) (CoincidenceDetector, error) {
	if config == nil {
		config = DefaultNMDADetectorConfig()
	} else {
		// Apply defaults to any zero values
		config.SetDefaults()
	}

	return NewNMDACoincidenceDetector(name, config)
}

// CreateSimpleTemporalCoincidenceDetector creates a simple temporal detector with optional custom configuration.
// If config is nil, uses reasonable defaults.
func CreateSimpleTemporalCoincidenceDetector(name string, config *SimpleTemporalDetectorConfig) (CoincidenceDetector, error) {
	if config == nil {
		config = DefaultSimpleTemporalDetectorConfig()
	} else {
		// Apply defaults to any zero values
		config.SetDefaults()
	}

	return NewSimpleTemporalCoincidenceDetector(name, config)
}
